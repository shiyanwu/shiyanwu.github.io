{"meta":{"title":"freebyte","subtitle":"","description":"自由处在！","author":"莱羊","url":"https://shiyanwu.github.io/freebyte","root":"/"},"pages":[{"title":"所有分类","date":"2023-07-31T09:53:19.918Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"categories/index.html","permalink":"https://shiyanwu.github.io/freebyte/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-31T09:53:10.528Z","updated":"2023-07-31T09:44:06.291Z","comments":true,"path":"404.html","permalink":"https://shiyanwu.github.io/freebyte/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"2023-07-31T09:53:10.532Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"friends/index.html","permalink":"https://shiyanwu.github.io/freebyte/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2023-07-31T09:53:10.530Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"mylist/index.html","permalink":"https://shiyanwu.github.io/freebyte/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-07-31T09:53:24.407Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"tags/index.html","permalink":"https://shiyanwu.github.io/freebyte/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-31T09:53:25.758Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"about/index.html","permalink":"https://shiyanwu.github.io/freebyte/about/index.html","excerpt":"","text":"下面写关于自己的内容"}],"posts":[{"title":"Java8 类型推断","slug":"10.Java8-类型推断","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.390Z","comments":false,"path":"2023/08/03/10.Java8-类型推断/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/10.Java8-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/","excerpt":"","text":"类型推断1. 先来说说泛型泛型是Java SE1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。通俗点将就是“类型的变量”。这种类型变量可以用在类、接口和方法的创建中。理解Java泛型最简单的方法是把它看成一种便捷语法，能节省你某些Java类型转换(casting)上的操作： 123List&lt;Apple&gt; box = new ArrayList&lt;Apple&gt;();box.add(new Apple());Apple apple =box.get(0); 这段上面的代码自身已表达的很清楚：box是一个装有Apple对象的List。get方法返回一个Apple对象实例，这个过程不需要进行类型转换。没有泛型，上面的代码需要写成这样： 1Apple apple = (Apple)box.get(0); 2. 泛型的尴尬泛型的最大优点是提供了程序的类型安全同时可以向后兼容，但也有尴尬的地方，就是每次定义时都要写明泛型的类型，这样显示指定不仅感觉有些冗长，最主要是很多时候不能够给出正确的类型参数，现在通过编译器自动推断泛型的参数类型，能够减少这样的情况，并提高代码可读性。 3. java7的泛型类型推断改进在以前的版本中使用泛型类型，需要在声明并赋值的时候，两侧都加上泛型类型。例如： 1Map&lt;String, String&gt; myMap = new HashMap&lt;String, String&gt;(); 你可能觉得:在声明变量的的时候已经指明了参数类型，为什么还要在初始化对象时再指定？幸好，在Java SE 7中，这种方式得以改进，现在你可以使用如下语句进行声明并赋值： 1Map&lt;String, String&gt; myMap = new HashMap&lt;&gt;(); //注意后面的&quot;&lt;&gt;&quot; 在这条语句中，编译器会根据变量声明时的泛型类型自动推断出实例化HashMap时的泛型类型。再次提醒一定要注意new HashMap后面的“&lt;&gt;”，只有加上这个“&lt;&gt;”才表示是自动类型推断，否则就是非泛型类型的HashMap，并且在使用编译器编译源代码时会给出一个警告提示。但是Java SE 7在创建泛型实例时的类型推断是有限制的：只有构造器的参数化类型在上下文中被显著的声明了，才可以使用类型推断，否则不行。例如：下面的例子在java 7无法正确编译（但现在在java8里面可以编译，因为根据方法参数来自动推断泛型的类型）： 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;A&quot;);//由于addAll期望获得Collection&lt;? extends String&gt;类型的参数，因此下面的语句无法通过list.addAll(new ArrayList&lt;&gt;()); 4.Java8的泛型类型推断改进java8里面泛型的目标类型推断主要2个： 支持通过方法上下文推断泛型目标类型 支持在方法调用链路当中，泛型类型推断传递到最后一个方法 让我们看看官网的例子 1234567class List&lt;E&gt; &#123; static &lt;Z&gt; List&lt;Z&gt; nil() &#123; ... &#125;; static &lt;Z&gt; List&lt;Z&gt; cons(Z head, List&lt;Z&gt; tail) &#123; ... &#125;; E head() &#123; ... &#125;&#125; 根据JEP101的特性，我们在调用上面方法的时候可以这样写 1234567891011//通过方法赋值的目标参数来自动推断泛型的类型List&lt;String&gt; l = List.nil();//而不是显示的指定类型//List&lt;String&gt; l = List.&lt;String&gt;nil();//通过前面方法参数类型推断泛型的类型List.cons(42, List.nil());//而不是显示的指定类型//List.cons(42, List.&lt;Integer&gt;nil());","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"java8 接口新的两种方法","slug":"1.Java8-接口的新的两种方法","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.390Z","comments":false,"path":"2023/08/03/1.Java8-接口的新的两种方法/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/1.Java8-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"Java8-接口新的两种方法java8 版之前，接口只有抽象方法，而在Java 8，为接口新增了两种类型的方法。 第一种是默认方法；第二种是静态方法。 1. 默认方法默认方法使用了default关键字修饰方法名，实际上接口不包含任何实现的方法，而在Java 8中，可以通过使用default关键字来添加默认的方法实现。 接口的实现类可以直接使用这些默认的方法，同时还可以重写默认的方法，这不是强制性的重写。默认方法使得开发者可以在不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。 这样我们就可以在不破坏原来代码的基础上扩展原有的类库，这听上去绝对很酷。但是从另外一个角度来看，这样做有点丧失接口的意义，使得接口定义和具体实现之间的界限模糊不清。可是好处也很明显，我们可以用一种很优雅的方式让接口变得更灵巧，也避免了代码冗余，同时还可以扩展原有类库。 这是一个例子： 1234567891011121314151617package com.ehking.example.java8.newfeature.demo01;/** * Created by shiyanwu on 2017/4/11. * 测试java8接口特性 */public interface Java8InterfaceDemo &#123; /** * 接口-默认方法 */ default void display() &#123; System.out.println(&quot;default method of interface&quot;); &#125; &#125; 由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。 之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了使接口没有引入与现有的实现不兼容发展 那么问题来了。由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，那么如果有冲突的情况我们怎么来判断使用哪个方法呢？默认方法判断冲突的规则如下： 一个声明在类里面的方法优先于任何默认方法。 否则，则会优先选取最具体的实现。 1.如果一个类从它的父类继承一个方法，又从它的父接口那里继承一个方法名相同的方法。此时，这个类会继承这个父类的方法，而忽略掉这个父接口的方法。 当一个类通过类继承的方式继承的方法不可用的时候，则一个接口中与这个方法名相同的默认方法就会作为一个备用方法。 2.当一个了实现一个有默认方法的接口时，可以不重写默认方法。但是，如果有两个接口的默认方法相同，而类C由同时implements这两个接口，则类C必须重写默认方法，否则编译错误。 尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。 2. 静态方法这种类型的静态方法与类中的静态方法相似，可以在接口中使用static关键字定义静态方法。如果我们要调用接口定义的静态方法，只需使用接口名就可以访问这些静态方法。比如： 12345678910111213141516package com.ehking.example.java8.newfeature.demo01;/** * Created by shiyanwu on 2017/4/11. * 测试java8接口特性 */public interface Java8InterfaceDemo &#123; /** * 接口-静态方法 */ static void show() &#123; System.out.println(&quot;static method of interface&quot;); &#125; &#125; 3. 接口和抽象类的比较Java8的这一个功能特性出来后，很多同学都反应了，java 8的接口都有实现方法了，跟抽象类还有什么区别？其实还是有的，请看下表对比: 相同点 不同点 1.都是抽象类型 1.抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承） 2.都可以有实现方法（以前接口不行） 2.抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系 3.都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现） 3.接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"Java8 Base64支持","slug":"11.Java8-Base64支持","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.389Z","comments":false,"path":"2023/08/03/11.Java8-Base64支持/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/11.Java8-Base64%E6%94%AF%E6%8C%81/","excerpt":"","text":"Base64支持对Base64编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，例子代码如下： 123456789101112131415161718192021222324252627282930313233343536package com.ehking.example.java8.newfeature.demo11;import java.nio.charset.StandardCharsets;import java.util.Base64;/** * &lt;p&gt; * java8 测试base64 */public class Java8Base64 &#123; public static void main(String[] args) &#123; final String text = &quot;Base64 finally in Java 8!&quot;; final String encoded = Base64 .getEncoder() .encodeToString(text.getBytes(StandardCharsets.UTF_8)); System.out.println(encoded); final String decoded = new String( Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8); System.out.println(decoded); &#125;&#125;","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"Java8 其它新特性","slug":"12.Java8-其它新特性","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-04T05:15:24.442Z","comments":false,"path":"2023/08/03/12.Java8-其它新特性/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/12.Java8-%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"强制终止进程当你用Java启动外部进程后，一旦这个进程崩溃，主程序就会陷入很麻烦的境地。现在，Java 8中的Process类提供了两个新方法，可以来帮你管制这些烦人的进程了。第一个是isAlive()方法，我们可以利用这个方法来判断指定的外部进程是否还存活着。第二个方法更强大，它是destroyForcibly()方法，可以将崩溃或者不再需要的进程强制终止。 StampedLock看到这个，忍不住有点激动人心。没有人喜欢在代码中使用同步，它会让你的程序效率更低，而且严重的还可能会引起程序崩溃。尽管如此，有时候我们还是不得不使用它。 当多个进程访问一个资源的时候，有多种方法可以进行同步。其中用得最多的一种是ReadWriteLock以及基于它的几种实现。它通过阻塞写线程的方式来允许多个线程并发的读，这样减少了线程之间的竞争。听起来还不错，但实际上这个锁实在是太慢了，尤其是当有许多写线程的时候。 值得高兴的是，现在Java 8中推出了一个新的读写锁，名字叫StampedLock。StampedLock不仅读写更快，而且还提供了很多强大的API来创建乐观锁。这样如果没有写操作在访问临界区域的话，你只需很低的开销就能获取到一个读锁。访问结束后你可以查询锁来判断这期间是否发生了写操作，如果有的话再选择进行重试，升级锁，或者放弃这个操作。 ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。 然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。 StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。 所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！ 下面是java doc提供的StampedLock一个例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Point &#123; private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) &#123; // an exclusively locked method long stamp = sl.writeLock(); try &#123; x += deltaX; y += deltaY; &#125; finally &#123; sl.unlockWrite(stamp); &#125; &#125; //下面看看乐观读锁案例 double distanceFromOrigin() &#123; // A read-only method long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁 double currentX = x, currentY = y; //将两个字段读入本地局部变量 if (!sl.validate(stamp)) &#123; //检查发出乐观读锁后同时是否有其他写锁发生？ stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁 try &#123; currentX = x; // 将两个字段读入本地局部变量 currentY = y; // 将两个字段读入本地局部变量 &#125; finally &#123; sl.unlockRead(stamp); &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125; /** * 下面是悲观读锁案例 */ void moveIfAtOrigin(double newX, double newY) &#123; // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try &#123; while (x == 0.0 &amp;&amp; y == 0.0) &#123; //循环，检查当前状态是否符合 long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁 if (ws != 0 L)&#123; //这是确认转为写锁是否成功 stamp = ws; //如果成功 替换票据 x = newX; //进行状态改变 y = newY; //进行状态改变 break; &#125; else&#123; //如果不能成功转换为写锁 sl.unlockRead(stamp); //我们显式释放读锁 stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试 &#125; &#125; &#125; finally &#123; sl.unlock(stamp); //释放读锁或写锁 &#125; &#125;&#125; 并行计数器这是又是一个多线程应用经常会用到的小工具，它提供了简单高效的新接口来实现多线程的并发读写计数器的功能，和AtomicInteger比起来，它要更快一些。相当赞的工具。 目录遍历遍历目录树这种事通常都得上Google搜下怎么实现（你很可能用的是Apache.FileUtils）。Java 8给Files类做了一次整容手术，增加了十个新的方法。其中一个是walk()方法，它遍历目录后会创建出一个惰性的流（文件系统很大的情况下非常有用）。 增强的随机数生成现在经常都在讨论密码或者密钥容易遭受攻击的事。程序的安全性是项很复杂的工程，并且很容易出错。这就是我为什么喜欢这个新的SecureRandom.getinstanceStrong()方法的原因，它能自动选择出当前JVM可用的最佳的随机数生成器。这样减少了获取失败的机率，同时也避免了默认的弱随机数生成器可能会导致密钥或者加密值容易被黑客攻破的问题。 几个新接口说明Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： 1234567Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test(&quot;foo&quot;); // truepredicate.negate().test(&quot;foo&quot;); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Function 接口 Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： 123Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply(&quot;123&quot;); // &quot;123&quot; Supplier 接口 Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new Person Consumer 接口 Consumer 接口表示执行在单个参数上的操作。 12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;)); Comparator 接口 Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法： 12345Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);comparator.compare(p1, p2); // &gt; 0comparator.reversed().compare(p1, p2); // &lt; 0","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"java8 方法引用","slug":"5.Java8-方法引用","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.391Z","comments":false,"path":"2023/08/03/5.Java8-方法引用/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/5.Java8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"五.方法引用方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。 语法：如果是静态方法，则是ClassName::methodName。如 Object ::equals如果是实例方法，则是Instance::methodName。如Object obj&#x3D;new Object();obj::equals;构造函数.则是ClassName::new 123456789101112131415161718192021222324252627282930package com.ehking.example.java8.newfeature.demo05;import java.util.function.Supplier;/** * Car类定义 */public class Car &#123; public static Car create(final Supplier&lt;Car&gt; supplier) &#123; return supplier.get(); &#125; public static void collide(final Car car) &#123; System.out.println(&quot;Collided &quot; + car.toString()); &#125; public void follow(final Car another) &#123; System.out.println(&quot;Following the &quot; + another.toString()); &#125; public void repair() &#123; System.out.println(&quot;Repaired &quot; + this.toString()); &#125;&#125; 引用的car测试例子： 1234567891011121314151617181920212223242526272829303132333435363738package com.ehking.example.java8.newfeature.demo05;import java.util.Arrays;/** * Created by shiyanwu on 2017/4/13. * java 测试 方法引用 */public class Java8MethodRef &#123; public static void main(String[] args) &#123; //第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class&lt;T&gt;::new。注意：这个构造器没有参数。 final Car car = Car.create(Car::new); final List&lt;Car&gt; cars = Arrays.asList(car); //第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。 cars.forEach(Car::collide); //第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参： cars.forEach(Car::repair); //第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数： final Car police = Car.create(Car::new); cars.forEach(police::follow); //Collided com.ehking.example.java8.newfeature.demo05.Car@4c98385c //Repaired com.ehking.example.java8.newfeature.demo05.Car@4c98385c //Following the com.ehking.example.java8.newfeature.demo05.Car@4c98385c &#125;&#125;","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"java8 Lambda","slug":"2.Java8-Lambda","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-04T05:18:27.295Z","comments":false,"path":"2023/08/03/2.Java8-Lambda/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/2.Java8-Lambda/","excerpt":"Java8-Lambda表达式1. Lambda表达式的使用Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。","text":"Java8-Lambda表达式1. Lambda表达式的使用Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。 Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成。比如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ehking.example.java8.newfeature.demo02;import java.util.Arrays;/** * java8 lambda 表达式 */public class Java8LambdaExpression &#123; public static void main(String[] args) &#123; Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach(e -&gt; System.out.print(e)); /** * 在上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如： */ Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach((String e) -&gt; System.out.print(e)); /** * 如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如： */ Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach(e -&gt; &#123; System.out.print(e); System.out.print(e); &#125;); /** * Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同： */ String separator = &quot;,&quot;; Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach((String e) -&gt; System.out.print(e + separator)); final String separator2 = &quot;,&quot;; Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach((String e) -&gt; System.out.print(e + separator2)); /** * Lambda表达式有返回值，返回值的类型也由编译器推理得出。 * 如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同： */ Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).sort((e1, e2) -&gt; e1.compareTo(e2)); Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).sort((e1, e2) -&gt; &#123; int result = e1.compareTo(e2); return result; &#125;); //现在创建一个线程，只需要这样写就可以了，旧版的写法相信大家都知道，这个是不是简洁了很多 new Thread(() -&gt; System.out.println(&quot;lambda实现的线程&quot;)).start(); &#125;&#125; 2. Lambda的使用条件Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。函数接口指的是只有一个方法的接口，这样的接口可以隐式转换为Lambda表达式，虚拟机会自动判断。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个方法，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义： 1234@FunctionalInterfacepublic interface Functional &#123; void method();&#125; 不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的: 1234567@FunctionalInterfacepublic interface FunctionalDefaultMethods &#123; void method(); default void defaultMethod() &#123; &#125;&#125;","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"java8 Stream API","slug":"4.Java8-Stream API","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.391Z","comments":false,"path":"2023/08/03/4.Java8-Stream API/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/4.Java8-Stream%20API/","excerpt":"","text":"Stream API流API是Java 8引入了函数式编程的证明，Stream API提供了元素流的函数式操作，包括list、set、map等，还支持过滤filtering、映射mapping、移除集合中的重复元素等。 可以从集合、数组、读缓冲区等获取流Stream。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。 流（Stream）仅仅代表着数据流，并没有数据结构，所以他遍历完一次之后便再也无法遍历（这点在编程时候需要注意，不像Collection，遍历多少次里面都还有数据），它的来源可以是Collection、array、io等等。 流作用是提供了一种操作大数据接口，让数据操作更容易和更快。它具有过滤、映射以及减少遍历数等方法，这些方法分两种：中间方法和终端方法，“流”抽象天生就该是持续的，中间方法永远返回的是Stream，因此如果我们要获取最终结果的话，必须使用终点操作才能收集流产生的最终结果。区分这两个方法是看他的返回值，如果是Stream则是中间方法，否则是终点方法。 中间的操作： filter - 排除所有与断言不匹配的元素。 map - 通过Function对元素执行一对一的转换。 flatMap - 通过FlatMapper将每个元素转变为无或更多的元素。 peek - 对每个遇到的元素执行一些操作。主要对调试很有用。 distinct - 根据.equals行为排除所有重复的元素。这是一个有状态的操作。 sorted - 确保流中的元素在后续的操作中，按照比较器（Comparator）决定的顺序访问。这是一个有状态的操作。 limit - 保证后续的操作所能看到的最大数量的元素。这是一个有状态的短路的操作。 substream - 确保后续的操作只能看到一个范围的（根据index）元素。像不能用于流的String.substring一样。也有两种形式，一种有一个开始索引，一种有一个结束索引。二者都是有状态的操作，有一个结束索引的形式也是一个短路的操作。 末端的操作： forEach - 对流中的每个元素执行一些操作。 toArray - 将流中的元素倾倒入一个数组。 reduce - 通过一个二进制操作将流中的元素合并到一起。 collect - 将流中的元素倾倒入某些容器，例如一个Collection或Map. min - 根据一个比较器找到流中元素的最小值。 max -根据一个比较器找到流中元素的最大值。 count - 计算流中元素的数量。 anyMatch - 判断流中是否至少有一个元素匹配断言。这是一个短路的操作。 allMatch - 判断流中是否每一个元素都匹配断言。这是一个短路的操作。 noneMatch - 判断流中是否没有一个元素匹配断言。这是一个短路的操作。 findFirst - 查找流中的第一个元素。这是一个短路的操作。 findAny - 查找流中的任意元素，可能对某些流要比findFirst代价低。这是一个短路的操作。 下面是一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.ehking.example.java8.newfeature.demo04;import java.util.Arrays;import java.util.Collection;import java.util.List;import java.util.Map;import java.util.stream.Collectors;/** * &lt;p&gt; * java8 stream 测试 */public class Java8StreamsDemo &#123; private enum Status &#123; OPEN, CLOSED &#125; private static final class Task &#123; private final Status status; private final Integer points; Task(final Status status, final Integer points) &#123; this.status = status; this.points = points; &#125; public Integer getPoints() &#123; return points; &#125; public Status getStatus() &#123; return status; &#125; @Override public String toString() &#123; return String.format(&quot;[%s, %d]&quot;, status, points); &#125; &#125; public static void main(String[] args) &#123; final Collection&lt;Task&gt; tasks = Arrays.asList( new Task(Status.OPEN, 5), new Task(Status.OPEN, 13), new Task(Status.CLOSED, 8) ); // Calculate total points of all active tasks using sum() final long totalPointsOfOpenTasks = tasks .stream() .filter(task -&gt; task.getStatus() == Status.OPEN) .mapToInt(Task::getPoints) .sum(); System.out.println(&quot;Total points: &quot; + totalPointsOfOpenTasks); // Calculate total points of all tasks final double totalPoints = tasks .stream() .parallel() .map(task -&gt; task.getPoints()) // or map( Task::getPoints ) .reduce(0, Integer::sum); System.out.println(&quot;Total points (all tasks): &quot; + totalPoints); // Group tasks by their status final Map&lt;Status, List&lt;Task&gt;&gt; map = tasks .stream() .collect(Collectors.groupingBy(Task::getStatus)); System.out.println(map); // Calculate the weight of each tasks (as percent of total points) final Collection&lt;String&gt; result = tasks .stream() // Stream&lt; String &gt; .mapToInt(Task::getPoints) // IntStream .asLongStream() // LongStream .mapToDouble(points -&gt; points / totalPoints) // DoubleStream .boxed() // Stream&lt; Double &gt; .mapToLong(weigth -&gt; (long) (weigth * 100)) // LongStream .mapToObj(percentage -&gt; percentage + &quot;%&quot;) // Stream&lt; String&gt; .collect(Collectors.toList()); // List&lt; String &gt; System.out.println(result); &#125;&#125;","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"Java8 Optional类","slug":"3.Java8-Optional","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-04T05:17:56.542Z","comments":false,"path":"2023/08/03/3.Java8-Optional/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/3.Java8-Optional/","excerpt":"","text":"Optional类Java 8在java.util包中新增了Optional类，Optional类是一个可以包含或不可以包含非空值的容器对象。每一个Java项目，最主要的重复语句就是检查空指针异常NullPointerException。我们使用任何对象，都需要检查此对象是否为空，如果对象不为空我们才执行处理语句。在Java 8之前，Google Guava引入了Optionals类来解决NullPointerException，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。 Optional类像是一个容器，它保存一个T类型的值或是null值。通过使用Optional类的isPresent()方法，我们可以检查指定的对象是否为空。 接下来看一点使用Optional的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.ehking.example.java8.newfeature.demo03;import java.util.Optional;/** * &lt;p&gt; * java8 optional测试 */public class Java8OptionalDemo &#123; public static void main(String[] args) &#123; Optional&lt;String&gt; fullName = Optional.ofNullable(null); System.out.println(&quot;Full Name is set? &quot; + fullName.isPresent()); System.out.println(&quot;Full Name: &quot; + fullName.orElseGet(() -&gt; &quot;[none]&quot;)); System.out.println(fullName.map(s -&gt; &quot;Hey &quot; + s + &quot;!&quot;).orElse(&quot;Hey Stranger!&quot;)); System.out.println(); Optional&lt;String&gt; firstName = Optional.of(&quot;Tom&quot;); System.out.println(&quot;First Name is set? &quot; + firstName.isPresent()); System.out.println(&quot;First Name: &quot; + firstName.orElseGet(() -&gt; &quot;[none]&quot;)); System.out.println(firstName.map(s -&gt; &quot;Hey &quot; + s + &quot;!&quot;).orElse(&quot;Hey Stranger!&quot;)); &#125;&#125;","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"java8 时间API","slug":"6.Java8-时间API","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.392Z","comments":false,"path":"2023/08/03/6.Java8-时间API/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/6.Java8-%E6%97%B6%E9%97%B4API/","excerpt":"","text":"时间API在Java 8版之前，如果我们想格式化日期，必须使用SimpleDateFormat类，用它格式化输入的日期类。Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。java.util.Date和后来的java.util.Calendar一直没有解决这个问题（甚至令开发者更加迷茫）。 因为上面这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训，为线程安全的），如果某个实例需要修改，则返回一个新的对象。 我们接下来看看java.time包中的关键类和各自的使用例子，而更多的情况则参考java8的api。 1.Clock类首先，Clock类使用时区来返回当前的纳秒时间和日期。Clock可以替代**System.currentTimeMillis()和TimeZone.getDefault()**。 2.LocalDate和LocalTime类LocalDate仅仅包含ISO-8601日历系统中的日期部分；LocalTime则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。 3.LocalDateTime类LocalDateTime类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。 4.ZoneDateTime类如果你需要特定时区的data&#x2F;time信息，则可以使用ZoneDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。 5.Duration类Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同。 以下是例子的详细说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.ehking.example.java8.newfeature.demo06;import java.time.Clock;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.Month;import java.time.ZoneId;import java.time.ZonedDateTime;/** * java8 测试datetime api */public class Java8DateTimeAPI &#123; public static void main(String[] args) &#123; /** * Clock类 */ final Clock clock = Clock.systemUTC(); System.out.println(clock.instant()); System.out.println(clock.millis()); /** * LocalDate类 */ final LocalDate date = LocalDate.now(); final LocalDate dateFromClock = LocalDate.now(clock); System.out.println(date); System.out.println(dateFromClock); /** * LocalTime类 */ final LocalTime time = LocalTime.now(); final LocalTime timeFromClock = LocalTime.now(clock); System.out.println(time); System.out.println(timeFromClock); /** * ZonedDateTime类 */ final ZonedDateTime zonedDatetime = ZonedDateTime.now(); final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now(clock); final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now(ZoneId.of(&quot;America/Los_Angeles&quot;)); System.out.println(zonedDatetime); System.out.println(zonedDatetimeFromClock); System.out.println(zonedDatetimeFromZone); /** * Duration类 */ final LocalDateTime from = LocalDateTime.of(2014, Month.APRIL, 16, 0, 0, 0); final LocalDateTime to = LocalDateTime.of(2015, Month.APRIL, 16, 23, 59, 59); final Duration duration = Duration.between(from, to); System.out.println(&quot;Duration in days: &quot; + duration.toDays()); System.out.println(&quot;Duration in hours: &quot; + duration.toHours()); &#125;&#125;","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"Java8 Nashorn JavaScript引擎","slug":"7.Java8-Nashorn JavaScript引擎","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.392Z","comments":false,"path":"2023/08/03/7.Java8-Nashorn JavaScript引擎/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/7.Java8-Nashorn%20JavaScript%E5%BC%95%E6%93%8E/","excerpt":"","text":"Nashorn JavaScript引擎Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。Nashorn JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，例子代码如下： 123456789101112131415161718192021222324252627282930313233package com.ehking.example.java8.newfeature.demo07;import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;/** * java测试 Nashorn JavaScript */public class Java8JavaScript &#123; public static void main(String[] args) &#123; ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName(&quot;JavaScript&quot;); System.out.println(engine.getClass().getName()); try &#123; System.out.println(&quot;output: &quot; + engine.eval(&quot;function show() &#123;return 10;&#125;; show();&quot;)); &#125; catch (ScriptException e) &#123; e.printStackTrace(); &#125; // jdk.nashorn.api.scripting.NashornScriptEngine // output: 10 &#125;&#125;","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"Java8 并行","slug":"8.Java8-并行","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.391Z","comments":false,"path":"2023/08/03/8.Java8-并行/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/8.Java8-%E5%B9%B6%E8%A1%8C/","excerpt":"","text":"并行数组排序Stream都有两种模式：顺序执行和并行执行。比如： 123List &lt;Person&gt; people = list.getStream.collect(Collectors.toList()); 并行执行为： 123List &lt;Person&gt; people = list.getStream.parallel().collect(Collectors.toList()); 在Java 7中已经有了Arrays.sort()方法可对对象进行排序，而在Java 8中，引入了新的并行排序，它比前者的排序速度更快，且遵循了Java 7引入的Fork&#x2F;Join框架，可以把排序任务分配给线程池中可用的多个线程。 Java 8在java.util.Arrays类中新增了并行排序功能，能够更充分地利用多线程机制，最重要的方法是parallelSort()，可以显著加快多核机器上的数组排序。 12345678910111213141516171819202122232425262728293031323334353637package com.ehking.example.java8.newfeature.demo08;import java.util.Arrays;import java.util.concurrent.ThreadLocalRandom;/** * &lt;p&gt; * 这段代码使用parallelSetAll()方法生成20000个随机数， * &lt;p&gt; * 然后使用parallelSort()方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。 */public class Java8ParallelArrays &#123; public static void main(String[] args) &#123; long[] arrayOfLong = new long[20000]; Arrays.parallelSetAll(arrayOfLong, index -&gt; ThreadLocalRandom.current().nextInt(1000000)); Arrays.stream(arrayOfLong).limit(10).forEach( i -&gt; System.out.print(i + &quot; &quot;)); System.out.println(); Arrays.parallelSort(arrayOfLong); Arrays.stream(arrayOfLong).limit(10).forEach( i -&gt; System.out.print(i + &quot; &quot;)); System.out.println(); &#125;&#125;","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]},{"title":"Java8 注解","slug":"9.Java8-注解","date":"2023-08-03T10:34:40.000Z","updated":"2023-08-03T06:41:41.391Z","comments":false,"path":"2023/08/03/9.Java8-注解/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/08/03/9.Java8-%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"注解1.重复注解自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。 在Java 8中使用@Repeatable注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。可以利用下面的代码说明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ehking.example.java8.newfeature.demo09;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * java8 重复注解测试 */public class RepeatAnnotations &#123; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Filters &#123; Filter[] value(); &#125; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Repeatable(Filters.class) public @interface Filter &#123; String value(); &#125; @Filter(&quot;filter1&quot;) @Filter(&quot;filter2&quot;) public interface Filterable &#123; &#125; public static void main(String[] args) &#123; for (Filter filter : Filterable.class.getAnnotationsByType(Filter.class)) &#123; System.out.println(filter.value()); &#125; &#125;&#125; 正如我们所见，这里的Filter类使用@Repeatable(Filters.class)注解修饰，而Filters是存放Filter注解的容器，编译器尽量对开发者屏蔽这些细节。这样，Filterable接口可以用两个Filter注解注释（这里并没有提到任何关于Filters的信息）。 另外，反射API提供了一个新的方法：getAnnotationsByType()，可以返回某个类型的重复注解，例如Filterable.class.getAnnoation(Filters.class)将返回两个Filter实例，输出到控制台的内容如下所示： filter1 filter2 详细的例子看：https://unmi.cc/java8-repeatable-annotations/#more-7668 2. 类型注解Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。比如: 12345678910111213//创建类实例new @Interned MyObject();//类型映射myString = (@NonNull String) str;//implements 语句中class UnmodifiableList&lt;T&gt; implements @Readonly List&lt;@Readonly T&gt; &#123; ... &#125;//throw exception声明void monitorTemperature() throws @Critical TemperatureException &#123; ... &#125; 需要注意的是，类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解。 12345678910111213141516171819202122232425262728293031323334353637package com.ehking.example.java8.newfeature.demo09;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.ArrayList;import java.util.Collection;/** * &lt;p&gt; * java8 注解可以用在任何地方 */public class Annotations &#123; @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.TYPE_USE, ElementType.TYPE_PARAMETER&#125;) public @interface NonEmpty &#123; &#125; public static class Holder&lt;@NonEmpty T&gt; extends @NonEmpty Object &#123; public void method() throws @NonEmpty Exception &#123; &#125; &#125; public static void main(String[] args) &#123; final Holder&lt;String&gt; holder = new @NonEmpty Holder&lt;String&gt;(); @NonEmpty Collection&lt;@NonEmpty String&gt; strings = new ArrayList&lt;&gt;(); &#125;&#125; ElementType.TYPE_USER和ElementType.TYPE_PARAMETER是Java 8新增的两个注解，用于描述注解的使用场景。Java 语言也做了对应的改变，以识别这些新增的注解。 TYPE_PARAMETER：表示该注解能写在类型参数的声明语句中。类型参数声明如： 、TYPE_USE:表示注解可以再任何用到类型的地方使用，比如允许在如下位置使用： 创建对象（用new关键字创建） 类型转换 使用implements实现接口 使用throws声明抛出异常","categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]}],"categories":[{"name":"Java8新特性","slug":"Java8新特性","permalink":"https://shiyanwu.github.io/freebyte/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://shiyanwu.github.io/freebyte/tags/Java8/"}]}