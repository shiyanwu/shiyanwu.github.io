{"meta":{"title":"freebyte","subtitle":"","description":"自由处在！","author":"莱羊","url":"https://shiyanwu.github.io/freebyte","root":"/"},"pages":[{"title":"","date":"2023-07-31T09:53:10.528Z","updated":"2023-07-31T09:44:06.291Z","comments":true,"path":"404.html","permalink":"https://shiyanwu.github.io/freebyte/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-07-31T09:53:25.758Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"about/index.html","permalink":"https://shiyanwu.github.io/freebyte/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2023-07-31T09:53:19.918Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"categories/index.html","permalink":"https://shiyanwu.github.io/freebyte/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-31T09:53:10.530Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"mylist/index.html","permalink":"https://shiyanwu.github.io/freebyte/mylist/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-07-31T09:53:10.532Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"friends/index.html","permalink":"https://shiyanwu.github.io/freebyte/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2023-07-31T09:53:24.407Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"tags/index.html","permalink":"https://shiyanwu.github.io/freebyte/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-07-31T09:44:06.292Z","updated":"2023-07-31T09:44:06.292Z","comments":true,"path":"2023/07/31/hello-world/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2023/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"java8 Lambda","slug":"java8-Lambda","date":"2020-04-23T10:34:40.000Z","updated":"2023-08-01T04:57:14.917Z","comments":false,"path":"2020/04/23/java8-Lambda/","link":"","permalink":"https://shiyanwu.github.io/freebyte/2020/04/23/java8-Lambda/","excerpt":"1.Lambda表达式的使用Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。","text":"1.Lambda表达式的使用Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。 Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成。比如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ehking.example.java8.newfeature.demo02;import java.util.Arrays;/** * Created by shiyanwu on 2017/4/12. * java8 lambda 表达式 */public class Java8LambdaExpression &#123; public static void main(String[] args) &#123; Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.print( e ) ); /** * 在上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如： */ Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.print( e ) ); /** * 如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如： */ Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; &#123; System.out.print( e ); System.out.print( e ); &#125; ); /** * Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同： */ String separator = &quot;,&quot;; Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.print( e + separator ) ); final String separator2 = &quot;,&quot;; Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.print( e + separator2 ) ); /** * Lambda表达式有返回值，返回值的类型也由编译器推理得出。 * 如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同： */ Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) ); Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; &#123; int result = e1.compareTo( e2 ); return result; &#125; ); //现在创建一个线程，只需要这样写就可以了，旧版的写法相信大家都知道，这个是不是简洁了很多 new Thread(() -&gt; System.out.println(&quot;lambda实现的线程&quot;)).start(); &#125;&#125; 2.Lambda的使用条件Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。函数接口指的是只有一个方法的接口，这样的接口可以隐式转换为Lambda表达式，虚拟机会自动判断。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个方法，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义： 1234@FunctionalInterfacepublic interface Functional &#123; void method();&#125; 不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的: 1234567@FunctionalInterfacepublic interface FunctionalDefaultMethods &#123; void method(); default void defaultMethod() &#123; &#125;&#125;","categories":[{"name":"java8","slug":"java8","permalink":"https://shiyanwu.github.io/freebyte/categories/java8/"}],"tags":[{"name":"java8 Lambda","slug":"java8-Lambda","permalink":"https://shiyanwu.github.io/freebyte/tags/java8-Lambda/"}]}],"categories":[{"name":"java8","slug":"java8","permalink":"https://shiyanwu.github.io/freebyte/categories/java8/"}],"tags":[{"name":"java8 Lambda","slug":"java8-Lambda","permalink":"https://shiyanwu.github.io/freebyte/tags/java8-Lambda/"}]}